#Clay Kynor and Glen Passow
#11.14.18
#Calculus


from math import sin,cos, tan, acos, asin, atan
from math import exp, expm1, e, pi
from math import log, log10, sqrt, log2
from math import ceil, floor

a = float(input("Input the left bound of your interval "))
b = float(input("Input the right bound of your interval "))
s = float(input("Input the step (smaller than 0.1)"))
func = input("Input a function which is continuous and differentialble on the given interval ")

print("")

#numeric offset for derivative calcs
dif = 0.00001

#makes what "zero" counts as for the program when identifying endpnts etc.
zero = (s**20)

critPnts = []
inflectionPnts = []

#uncertainty
unc = s/2

#This makes a weird issue as the last value will go beyond the end of the interval if the values do not come out right on
n = int((b-a)//s) + 1

#make x list
xvals=[]

#fill x list
for i in range(0,n):
	xvals.append(a + i*s)

#make y list
yvals=[]

#fill y list
for i in range(0,n):
	x = a + i*s
	yvals.append(eval(func))
 
#makes f' lst
f1 = []

#fill f' list
for i in range(0,n):
	x = a + i*s + dif
	f1y1 = eval(func)
	x = a + i*s - dif
	f1y2 = eval(func)
    
	f1Val = (f1y1-f1y2)/(2*dif)
	f1.append(f1Val)

#make f'' list
f2 = []

#fill f'' list
for i in range (0,n):
	x = a + i*s + dif
	f2y1 = eval(func)
    
	x = a + i*s - dif
	f2y2 = eval(func)
    
	x = a + i*s
	f2y3 = eval(func)
    
	#To find this equation simply plug the first derivative back into itself....if that makes sense.
	f2Val = (f2y1 - 2*f2y3 +f2y2)/(dif**2)
	f2.append(f2Val)

#print('X values', xvals)
#print('Y values', yvals)
#print("F' values", f1)
#print("F'' values", f2)

def float_round(num, places = 0, direction = ceil):
	return direction(num * (10**places)) / float(10**places)
    

#add this first x value for listing purposes
inflectionPnts.append(float_round((xvals[-1])))

if abs(f1[0]) == f1[0]:
	print('Local minumum at the endpoint (', float_round(xvals[0], 2, round), ',', float_round(yvals[0], 2, round), ')')
	state = True
else:
	print('Local maximum at the endpoint (', float_round(xvals[0], 2, round), ',', float_round(yvals[0], 2, round), ')')
	state = False
    
#add to crit pnt lsit
critPnts.append(float_round(xvals[0], 2, round))

#Think about it. If your values go +, +, +, -, -, - There are two places that there will be a sign change looking to the sides...We need the x value between the two
#Find the internal critical points
for i in range(1,n-2):
    if abs((f1[i-1]) * (f1[i+1])) > zero:
        if (f1[i-1]) * (f1[i+1]) < 0:
            if f1[i]*f1[i+1] < 0:
            	pnt = float_round(((xvals[i] + xvals[i+1])/2), 2, round)
            	critPnts.append(pnt)
            	if abs(f2[i]) == f2[i]:
                	print('Local minimum at x = ',pnt, '+/-',unc)
            	else:
                	print('Local maximum at x = ', pnt, '+/-',unc)
#not finding the local max for cos
#revisit how the plus or minus is displayed

    
if abs(f1[-1]) == f1[-1]:
	print('Local maximum at the endpoint (', float_round(xvals[-1], 2, round), ',', float_round(yvals[-1], 2, round), ')')
else:
	print('Local minimum at the endpoint (', float_round(xvals[-1], 2, round), ',', float_round(yvals[-1], 2, round), ')')
#add to crit pnt lsit
critPnts.append(float_round(xvals[-1], 2, round))
print("")
               	 
#Find the inflection points
for i in range(1,n-2):
    if abs((f2[i-1]) * (f2[i+1])) > zero:
        if (f2[i-1]) * (f2[i+1]) < 0:
            if f2[i]*f2[i+1] < 0:
            	pnt = float_round(((xvals[i] + xvals[i+1])/2), 5, round)
            	inflectionPnts.append(pnt)
            	print('Inflection point at (', pnt, '+/-',unc,')')
print("")

#increasing/decreasing
reps = len(critPnts) - 1
for i in range (0, reps):
    if state == True:
        print('increasing on interval [',critPnts[i],', ',critPnts[i+1],']')
    	state = False
    else:
        print('decreasing on interval [',critPnts[i],', ',critPnts[i+1],']')
        state = True
print("")

#concave up/concave down
reps = len(inflectionPnts) - 1

#Add the last x value for marking purposes
inflectionPnts.append(float_round((xvals[-1])))

#THIS SEEMS SKETCH
if f2[1] > 0:
	state = True
	concavity = True
if f2[1] < 0:
    state = False
    concavity = True
else:
	concavity = False

if concavity != False:
    #If only one interval for concavity
    if reps == 0:
        if state == True:
            print('concave up on interval [',inflectionPnts[-2],', ',inflectionPnts[-1],']')
        else:
            print('concave down on interval [',inflectionPnts[-2],', ',inflectionPnts[-1],']')
    
    #make the first concave interval
    if reps != 0:
        if state == True:
            print('concave up on interval [',inflectionPnts[0],', ',inflectionPnts[1],')')
            state = False
        else:
            print('concave down on interval [',inflectionPnts[0],', ',inflectionPnts[1],')')
            state = True
        
    #make all of the inner convavity intervals
    for i in range (0, reps-1):
        if state == True:
            print('concave up on interval (',inflectionPnts[i+1],', ',inflectionPnts[i+2],')')
            state = False
        else:
            print('concave down on interval (',inflectionPnts[i+1],', ',inflectionPnts[i+2],')')
            state = True
       	 
    #make exterior concavity intervals
    if reps != 0:
        if state == True:
            print('concave up on interval (',inflectionPnts[-2],', ',inflectionPnts[-1],']')
        else:
            print('concave down on interval (',inflectionPnts[-2],', ',inflectionPnts[-1],']')
if concavity == False:
    print("There is no concavity on the given interval")